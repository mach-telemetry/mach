use std::{
    sync::{Arc, atomic::{AtomicU64, Ordering::SeqCst}},
    fs::{OpenOptions, File},
    path::{PathBuf, Path},
    io::{prelude::*, SeekFrom, Result},
    convert::TryInto,
};
use lazy_static::*;

lazy_static! {
    pub static ref DATADIR: PathBuf = PathBuf::from("/nvme/fsolleza/output");
}

pub struct InnerFileList {
    head_offset: u64,
    head_id: u64,
    head_bytes: u64,
    version: AtomicUsize,
}

impl InnerFileList {
    fn push(&mut self) {
    }
}


// file layout
// block1 offset: 8 bytes,
// block1 prev offset: 8 bytes,
// block1 prev id: 8 bytes,

struct InnerFileMetadata {
    offset: u64,
    id: u64,
    bytes: u64,
}

impl InnerFileMetadata {
    pub fn as_bytes(&self) -> [u8; 24] {
        let mut bytes = [0u8; 24];
        bytes[..8].copy_from_slice(&self.offset.to_be_bytes()[..]);
        bytes[8..16].copy_from_slice(&self.id.to_be_bytes()[..]);
        bytes[16..24].copy_from_slice(&self.bytes.to_be_bytes()[..]);
        bytes
    }

    pub fn from_bytes(bytes: &[u8; 24]) -> Self {
        let offset = u64::from_be_bytes(bytes[..8].try_into().unwrap());
        let id = u64::from_be_bytes(bytes[8..16].try_into().unwrap());
        let bytes = u64::from_be_bytes(bytes[16..24].try_into().unwrap());
        Self {
            offset,
            id,
            bytes
        }
    }

    fn size() -> usize {
        std::mem::size_of<Self>()
    }
}


const SECTSZ: usize = 16;

struct InnerFileWriter {
    section_offset: usize,
    data_offset: u64,
    counter: usize,
    id: u64,
    file: File
}

impl InnerFileWriter {

    fn seek_to_meta_offset(&mut self) -> Result<()> {
        self.file.seek(SeekFrom::Start(self.section_offset + self.counter * InnerFileMetadata::size()))
    }

    fn seek_to_data_offset(&mut self) -> Result<()> {
        self.file.seek(SeekFrom::Start(self.data_offset))
    }

    fn try_move_to_next_section(&mut self) -> Result<()> {
        if self.counter == 0 {
            self.section_offset = 0;
            //+ 8 because those 8 bytes will contain the next section's offset
            self.data_offset = InnerFileMetadata::size() * SECTSZ + 8;
        }
        else if self.counter % SECTSZ == 0 {
            self.seek_to_meta_offset()?;
            self.file.write_all(&self.data_offset.to_be_bytes()[..])?;
            self.section_offset = self.data_offset;

            // And update the data_offset for this new section 
            self.data_offset = self.section_offset + InnerFileMetadata::size() * SECTSZ + 8;
        }
    }


    pub fn append_bytes(&mut self, bytes: &[u8]) -> Result<InnerFileMetadata> {

        self.try_move_to_next_section()?;

        let len = bytes.len();
        let inner = InnerFileMetadata {
            offset: self.offset,
            id: self.id,
            bytes: len as u64,
        };
        let meta = inner.as_bytes();

        // Write the metadata
        self.seek_to_meta_offset()?;
        self.file.write_all(&meta[..])?;

        // Write the data

        // If the current section has SECTSZ chunks, record location of the next section, move to
        // the next section
        if counter % SECTSZ == 0 {
            // Write the offset of the next section at the end of this
            self.file.seek(SeekFrom::Start(section_offset + counter * InnerFileMetadata::size()))?;
            self.file.write_all(&self.data_offset.to_be_bytes()[..])?;
            self.section_offset = self.data_offset;

            // And update the data_offset for this new section (+ 8 because those 8 bytes will
            // contain the next section's offset
            self.data_offset = self.section_offset + InnerFileMetadata::size() * SECTSZ + 8;
            self.file.seek(SeekFrom::Start(self.offset))?;
        } else {
            self.file.seek(SeekFrom::Start(section_offset + counter * InnerFileMetadata::size()))?;
        }

        // Write the offset information
        self.file.write_all(&meta[..])?;

        self.file.seek(SeekFrom::Start(self.offset));
        self.file.write_all(bytes)?;
        self.offset += len;

        inner
    }

    pub fn new(id: usize) -> Result<Self> {
        //let id = shared_id.load(SeqCst);
        let path = DATADIR.join(format!("data_{}", id));
        let file = OpenOptions::new().write(true).append(true).open(path)?;

        Ok(FileWriter {
            offset: 0,
            id,
            file,
            //shared_id,
        })
    }
}


